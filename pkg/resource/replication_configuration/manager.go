// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

// Code generated by ack-generate. DO NOT EDIT.

package replication_configuration

import (
	"context"

	ackv1alpha1 "github.com/aws-controllers-k8s/runtime/apis/core/v1alpha1"
	ackcompare "github.com/aws-controllers-k8s/runtime/pkg/compare"
	ackcfg "github.com/aws-controllers-k8s/runtime/pkg/config"
	ackmetrics "github.com/aws-controllers-k8s/runtime/pkg/metrics"
	ackrt "github.com/aws-controllers-k8s/runtime/pkg/runtime"
	ackrtlog "github.com/aws-controllers-k8s/runtime/pkg/runtime/log"
	acktypes "github.com/aws-controllers-k8s/runtime/pkg/types"
	ackutil "github.com/aws-controllers-k8s/runtime/pkg/util"
	"github.com/aws/aws-sdk-go-v2/aws"
	svcsdk "github.com/aws/aws-sdk-go-v2/service/ecr"
	"github.com/aws/aws-sdk-go-v2/service/ecr/types"
	"github.com/go-logr/logr"
	rtclient "sigs.k8s.io/controller-runtime/pkg/client"

	svcapitypes "github.com/aws-controllers-k8s/ecr-controller/apis/v1alpha1"
)

var (
	_ = ackutil.InStrings
	_ = ackrt.MissingImageTagValue
	_ = svcapitypes.ReplicationConfiguration{}
)

// +kubebuilder:rbac:groups=ecr.services.k8s.aws,resources=replicationconfigurations,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=ecr.services.k8s.aws,resources=replicationconfigurations/status,verbs=get;update;patch

// resourceManager is responsible for providing a consistent API to work with
// ECR API resources.
type resourceManager struct {
	rr           acktypes.AWSResourceReconciler
	awsAccountID ackv1alpha1.AWSAccountID
	awsRegion    ackv1alpha1.AWSRegion
	cfg          ackcfg.Config
	log          logr.Logger
	metrics      *ackmetrics.Metrics
	sdkapi       *svcsdk.Client
}

// ReadOne returns resource state for a specific PK.
func (rm *resourceManager) ReadOne(
	ctx context.Context,
	r acktypes.AWSResource,
) (acktypes.AWSResource, error) {
	var err error
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.ReadOne")
	defer func() { exit(err) }()

	res := r.(*resource)

	input := &svcsdk.DescribeRegistryInput{}
	// Note: DescribeRegistry doesn't take RegistryId parameter in the input

	resp, err := rm.sdkapi.DescribeRegistry(ctx, input)
	rm.metrics.RecordAPICall("READ_ONE", "DescribeRegistry", err)
	if err != nil {
		rlog.Info("ReadOne: DescribeRegistry failed", "error", err)
		return nil, err
	}

	rlog.Info("ReadOne: DescribeRegistry succeeded")

	// Create a new resource with the response data
	ko := res.ko.DeepCopy()
	if resp.ReplicationConfiguration != nil {
		rlog.Info("ReadOne: Found AWS replication config", "rulesCount", len(resp.ReplicationConfiguration.Rules))

		// Convert AWS SDK type to our API type, even if rules array is empty
		var rules []*svcapitypes.ReplicationRule
		if len(resp.ReplicationConfiguration.Rules) > 0 {
			rules = make([]*svcapitypes.ReplicationRule, len(resp.ReplicationConfiguration.Rules))

			for i, awsRule := range resp.ReplicationConfiguration.Rules {
				// Convert destinations
				destinations := make([]*svcapitypes.ReplicationDestination, len(awsRule.Destinations))
				for j, awsDest := range awsRule.Destinations {
					destinations[j] = &svcapitypes.ReplicationDestination{
						RegistryID: awsDest.RegistryId,
						Region:     awsDest.Region,
					}
				}

				// Convert repository filters
				var repositoryFilters []*svcapitypes.RepositoryFilter
				if awsRule.RepositoryFilters != nil {
					repositoryFilters = make([]*svcapitypes.RepositoryFilter, len(awsRule.RepositoryFilters))
					for k, awsFilter := range awsRule.RepositoryFilters {
						filterType := string(awsFilter.FilterType)
						repositoryFilters[k] = &svcapitypes.RepositoryFilter{
							Filter:     awsFilter.Filter,
							FilterType: &filterType,
						}
					}
				}

				rules[i] = &svcapitypes.ReplicationRule{
					Destinations:      destinations,
					RepositoryFilters: repositoryFilters,
				}
			}
		} else {
			rlog.Info("ReadOne: Found empty replication configuration, returning resource with empty rules")
		}

		ko.Spec.ReplicationConfiguration = &svcapitypes.ReplicationConfigurationForRegistry{
			Rules: rules,
		}
		rlog.Info("ReadOne: Returning resource with rules", "rulesCount", len(rules))
	} else {
		// If there's no replication configuration in AWS at all, return empty rules
		rlog.Info("ReadOne: No replication configuration in AWS, returning resource with empty rules")
		ko.Spec.ReplicationConfiguration = &svcapitypes.ReplicationConfigurationForRegistry{
			Rules: []*svcapitypes.ReplicationRule{},
		}
	}

	return newResource(rm.rr, ko), nil
}

// Create creates a resource
func (rm *resourceManager) Create(
	ctx context.Context,
	desired acktypes.AWSResource,
) (created acktypes.AWSResource, cErr error) {
	var err error
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.Create")
	defer func() { exit(err) }()

	res := desired.(*resource)

	input := &svcsdk.PutReplicationConfigurationInput{}

	// Debug logging - check current AWS state before modification
	rlog.Info("Create: Processing resource", "name", res.ko.GetName(), "namespace", res.ko.GetNamespace())
	
	// First, check what's currently in AWS
	currentResp, currentErr := rm.sdkapi.DescribeRegistry(ctx, &svcsdk.DescribeRegistryInput{})
	if currentErr != nil {
		rlog.Info("Create: Failed to describe current registry state", "error", currentErr)
	} else {
		if currentResp.ReplicationConfiguration != nil {
			rlog.Info("Create: Current AWS replication config", "currentRulesCount", len(currentResp.ReplicationConfiguration.Rules))
			for i, rule := range currentResp.ReplicationConfiguration.Rules {
				rlog.Info("Create: Current AWS rule", "ruleIndex", i, "destinationsCount", len(rule.Destinations), "filtersCount", len(rule.RepositoryFilters))
			}
		} else {
			rlog.Info("Create: No current replication configuration in AWS")
		}
	}
	
	// Debug our desired state
	rlog.Info("Create: ReplicationConfiguration spec", "spec", res.ko.Spec)
	if res.ko.Spec.ReplicationConfiguration != nil {
		rlog.Info("Create: Found replication configuration", "rulesCount", len(res.ko.Spec.ReplicationConfiguration.Rules))
		for i, rule := range res.ko.Spec.ReplicationConfiguration.Rules {
			rlog.Info("Create: Desired rule", "ruleIndex", i, "destinationsCount", len(rule.Destinations), "filtersCount", len(rule.RepositoryFilters))
		}
	} else {
		rlog.Info("Create: No replication configuration in spec")
	}

	// Convert our API type to AWS SDK type
	if res.ko.Spec.ReplicationConfiguration != nil {
		rules := make([]types.ReplicationRule, len(res.ko.Spec.ReplicationConfiguration.Rules))
		
		for i, rule := range res.ko.Spec.ReplicationConfiguration.Rules {
			// Convert destinations
			destinations := make([]types.ReplicationDestination, len(rule.Destinations))
			for j, dest := range rule.Destinations {
				destinations[j] = types.ReplicationDestination{
					RegistryId: dest.RegistryID,
					Region:     dest.Region,
				}
			}
			
			// Convert repository filters
			var repositoryFilters []types.RepositoryFilter
			if rule.RepositoryFilters != nil {
				repositoryFilters = make([]types.RepositoryFilter, len(rule.RepositoryFilters))
				for k, filter := range rule.RepositoryFilters {
					repositoryFilters[k] = types.RepositoryFilter{
						Filter:     filter.Filter,
						FilterType: types.RepositoryFilterType(*filter.FilterType),
					}
				}
			}
			
			rules[i] = types.ReplicationRule{
				Destinations:      destinations,
				RepositoryFilters: repositoryFilters,
			}
		}
		
		input.ReplicationConfiguration = &types.ReplicationConfiguration{
			Rules: rules,
		}
		
		rlog.Info("Create: Sending to AWS", "rulesCount", len(rules))
	} else {
		rlog.Info("Create: Sending empty replication configuration to AWS")
	}

	_, err = rm.sdkapi.PutReplicationConfiguration(ctx, input)
	rm.metrics.RecordAPICall("CREATE", "PutReplicationConfiguration", err)
	if err != nil {
		rlog.Info("Create: PutReplicationConfiguration failed", "error", err)
		return nil, err
	}
	
	rlog.Info("Create: PutReplicationConfiguration succeeded")

	// Check AWS state immediately after our call
	afterResp, afterErr := rm.sdkapi.DescribeRegistry(ctx, &svcsdk.DescribeRegistryInput{})
	if afterErr != nil {
		rlog.Info("Create: Failed to describe registry state after PUT", "error", afterErr)
	} else {
		if afterResp.ReplicationConfiguration != nil {
			rlog.Info("Create: AWS replication config after PUT", "rulesCount", len(afterResp.ReplicationConfiguration.Rules))
			for i, rule := range afterResp.ReplicationConfiguration.Rules {
				rlog.Info("Create: AWS rule after PUT", "ruleIndex", i, "destinationsCount", len(rule.Destinations), "filtersCount", len(rule.RepositoryFilters))
			}
		} else {
			rlog.Info("Create: No replication configuration in AWS after PUT")
		}
	}

	// Read back the created resource
	return rm.ReadOne(ctx, desired)
}

// Update modifies a resource
func (rm *resourceManager) Update(
	ctx context.Context,
	desired acktypes.AWSResource,
	latest acktypes.AWSResource,
	delta *ackcompare.Delta,
) (updated acktypes.AWSResource, uErr error) {
	// Same as create for replication configuration - it's a put operation
	return rm.Create(ctx, desired)
}

// Delete removes a resource
func (rm *resourceManager) Delete(
	ctx context.Context,
	desired acktypes.AWSResource,
) (acktypes.AWSResource, error) {
	var err error
	var rlog = ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.Delete")
	defer func() { exit(err) }()

	_ = desired.(*resource)

	// Delete replication configuration by putting an empty configuration
	input := &svcsdk.PutReplicationConfigurationInput{
		ReplicationConfiguration: &types.ReplicationConfiguration{
			Rules: []types.ReplicationRule{},
		},
	}

	_, err = rm.sdkapi.PutReplicationConfiguration(ctx, input)
	rm.metrics.RecordAPICall("DELETE", "PutReplicationConfiguration", err)
	if err != nil {
		return nil, err
	}
	return desired, nil
}

// ClearResolvedReferences clears resolved references
func (rm *resourceManager) ClearResolvedReferences(
	r acktypes.AWSResource,
) acktypes.AWSResource {
	return r
}

// ARNFromName returns an AWS resource ARN from the supplied name
func (rm *resourceManager) ARNFromName(name string) string {
	return ""
}

// LateInitialize sets the late-initialized values from the AWS resource
func (rm *resourceManager) LateInitialize(
	ctx context.Context,
	latest acktypes.AWSResource,
) (acktypes.AWSResource, error) {
	return latest, nil
}

// EnsureTags ensures that tags are present inside the AWSResource.
func (rm *resourceManager) EnsureTags(
	ctx context.Context,
	r acktypes.AWSResource,
	md acktypes.ServiceControllerMetadata,
) error {
	// ReplicationConfiguration doesn't support tags
	return nil
}

// FilterSystemTags filters out system tags from the resource
func (rm *resourceManager) FilterSystemTags(
	r acktypes.AWSResource,
) {
	// ReplicationConfiguration doesn't support tags - no-op
}

// IsSynced returns true if the resource is synced
func (rm *resourceManager) IsSynced(ctx context.Context, r acktypes.AWSResource) (bool, error) {
	var err error
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.IsSynced")
	defer func() { exit(err) }()

	res := r.(*resource)

	// Read current AWS state to compare with desired
	latest, err := rm.ReadOne(ctx, r)
	if err != nil {
		rlog.Info("IsSynced: Failed to read AWS state", "error", err)
		return false, err
	}

	latestRes := latest.(*resource)

	// Compare desired vs actual using delta
	delta := newResourceDelta(res, latestRes)
	if len(delta.Differences) == 0 {
		rlog.Info("IsSynced: Resource is synced - no differences found")
		return true, nil
	}

	rlog.Info("IsSynced: Resource not synced", "differences", len(delta.Differences))
	for _, diff := range delta.Differences {
		rlog.Info("IsSynced: Difference found", "path", diff.Path, "desired", diff.A, "actual", diff.B)
	}

	return false, nil
}

// ResolveReferences resolves references in the resource
func (rm *resourceManager) ResolveReferences(
	ctx context.Context,
	reader rtclient.Reader,
	r acktypes.AWSResource,
) (acktypes.AWSResource, bool, error) {
	return r, false, nil // No references to resolve for ReplicationConfiguration
}

// newResourceManager returns a new struct implementing
// acktypes.AWSResourceManager that handles CRUD operations on the supplied
// resource.
func newResourceManager(
	cfg ackcfg.Config,
	clientcfg aws.Config,
	log logr.Logger,
	metrics *ackmetrics.Metrics,
	rr acktypes.Reconciler,
	awsAccountID ackv1alpha1.AWSAccountID,
	awsRegion ackv1alpha1.AWSRegion,
) (*resourceManager, error) {
	return &resourceManager{
		rr:           rr.(acktypes.AWSResourceReconciler),
		awsAccountID: awsAccountID,
		awsRegion:    awsRegion,
		cfg:          cfg,
		log:          log,
		metrics:      metrics,
		sdkapi:       svcsdk.NewFromConfig(clientcfg),
	}, nil
}
