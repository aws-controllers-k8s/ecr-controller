// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

// Code generated by ack-generate. DO NOT EDIT.

package replication_configuration

import (
	"context"

	ackv1alpha1 "github.com/aws-controllers-k8s/runtime/apis/core/v1alpha1"
	ackcompare "github.com/aws-controllers-k8s/runtime/pkg/compare"
	ackcfg "github.com/aws-controllers-k8s/runtime/pkg/config"
	ackmetrics "github.com/aws-controllers-k8s/runtime/pkg/metrics"
	ackrt "github.com/aws-controllers-k8s/runtime/pkg/runtime"
	ackrtlog "github.com/aws-controllers-k8s/runtime/pkg/runtime/log"
	acktypes "github.com/aws-controllers-k8s/runtime/pkg/types"
	ackutil "github.com/aws-controllers-k8s/runtime/pkg/util"
	"github.com/aws/aws-sdk-go-v2/aws"
	svcsdk "github.com/aws/aws-sdk-go-v2/service/ecr"
	"github.com/aws/aws-sdk-go-v2/service/ecr/types"
	"github.com/go-logr/logr"
	rtclient "sigs.k8s.io/controller-runtime/pkg/client"

	svcapitypes "github.com/aws-controllers-k8s/ecr-controller/apis/v1alpha1"
)

var (
	_ = ackutil.InStrings
	_ = ackrt.MissingImageTagValue
	_ = svcapitypes.ReplicationConfiguration{}
)

// +kubebuilder:rbac:groups=ecr.services.k8s.aws,resources=replicationconfigurations,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=ecr.services.k8s.aws,resources=replicationconfigurations/status,verbs=get;update;patch

// resourceManager is responsible for providing a consistent API to work with
// ECR API resources.
type resourceManager struct {
	rr           acktypes.AWSResourceReconciler
	awsAccountID ackv1alpha1.AWSAccountID
	awsRegion    ackv1alpha1.AWSRegion
	cfg          ackcfg.Config
	log          logr.Logger
	metrics      *ackmetrics.Metrics
	sdkapi       *svcsdk.Client
}

// ReadOne returns resource state for a specific PK.
func (rm *resourceManager) ReadOne(
	ctx context.Context,
	r acktypes.AWSResource,
) (acktypes.AWSResource, error) {
	var err error
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.ReadOne")
	defer func() { exit(err) }()

	res := r.(*resource)

	input := &svcsdk.DescribeRegistryInput{}
	// Note: DescribeRegistry doesn't take RegistryId parameter in the input

	resp, err := rm.sdkapi.DescribeRegistry(ctx, input)
	rm.metrics.RecordAPICall("READ_ONE", "DescribeRegistry", err)
	if err != nil {
		return nil, err
	}

	// Create a new resource with the response data
	ko := res.ko.DeepCopy()
	if resp.ReplicationConfiguration != nil {
		// Convert AWS SDK type to our API type
		rules := make([]*svcapitypes.ReplicationRule, len(resp.ReplicationConfiguration.Rules))
		
		for i, awsRule := range resp.ReplicationConfiguration.Rules {
			// Convert destinations
			destinations := make([]*svcapitypes.ReplicationDestination, len(awsRule.Destinations))
			for j, awsDest := range awsRule.Destinations {
				destinations[j] = &svcapitypes.ReplicationDestination{
					RegistryID: awsDest.RegistryId,
					Region:     awsDest.Region,
				}
			}
			
			// Convert repository filters
			var repositoryFilters []*svcapitypes.RepositoryFilter
			if awsRule.RepositoryFilters != nil {
				repositoryFilters = make([]*svcapitypes.RepositoryFilter, len(awsRule.RepositoryFilters))
				for k, awsFilter := range awsRule.RepositoryFilters {
					filterType := string(awsFilter.FilterType)
					repositoryFilters[k] = &svcapitypes.RepositoryFilter{
						Filter:     awsFilter.Filter,
						FilterType: &filterType,
					}
				}
			}
			
			rules[i] = &svcapitypes.ReplicationRule{
				Destinations:      destinations,
				RepositoryFilters: repositoryFilters,
			}
		}
		
		ko.Spec.ReplicationConfiguration = &svcapitypes.ReplicationConfigurationForRegistry{
			Rules: rules,
		}
	} else {
		// If there's no replication configuration, set to nil
		ko.Spec.ReplicationConfiguration = nil
	}

	return newResource(rm.rr, ko), nil
}

// Create creates a resource
func (rm *resourceManager) Create(
	ctx context.Context,
	desired acktypes.AWSResource,
) (created acktypes.AWSResource, cErr error) {
	var err error
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.Create")
	defer func() { exit(err) }()

	res := desired.(*resource)

	input := &svcsdk.PutReplicationConfigurationInput{}

	// Convert our API type to AWS SDK type
	if res.ko.Spec.ReplicationConfiguration != nil {
		rules := make([]types.ReplicationRule, len(res.ko.Spec.ReplicationConfiguration.Rules))
		
		for i, rule := range res.ko.Spec.ReplicationConfiguration.Rules {
			// Convert destinations
			destinations := make([]types.ReplicationDestination, len(rule.Destinations))
			for j, dest := range rule.Destinations {
				destinations[j] = types.ReplicationDestination{
					RegistryId: dest.RegistryID,
					Region:     dest.Region,
				}
			}
			
			// Convert repository filters
			var repositoryFilters []types.RepositoryFilter
			if rule.RepositoryFilters != nil {
				repositoryFilters = make([]types.RepositoryFilter, len(rule.RepositoryFilters))
				for k, filter := range rule.RepositoryFilters {
					repositoryFilters[k] = types.RepositoryFilter{
						Filter:     filter.Filter,
						FilterType: types.RepositoryFilterType(*filter.FilterType),
					}
				}
			}
			
			rules[i] = types.ReplicationRule{
				Destinations:      destinations,
				RepositoryFilters: repositoryFilters,
			}
		}
		
		input.ReplicationConfiguration = &types.ReplicationConfiguration{
			Rules: rules,
		}
	}

	_, err = rm.sdkapi.PutReplicationConfiguration(ctx, input)
	rm.metrics.RecordAPICall("CREATE", "PutReplicationConfiguration", err)
	if err != nil {
		return nil, err
	}

	// Read back the created resource
	return rm.ReadOne(ctx, desired)
}

// Update modifies a resource
func (rm *resourceManager) Update(
	ctx context.Context,
	desired acktypes.AWSResource,
	latest acktypes.AWSResource,
	delta *ackcompare.Delta,
) (updated acktypes.AWSResource, uErr error) {
	// Same as create for replication configuration - it's a put operation
	return rm.Create(ctx, desired)
}

// Delete removes a resource
func (rm *resourceManager) Delete(
	ctx context.Context,
	desired acktypes.AWSResource,
) (acktypes.AWSResource, error) {
	var err error
	var rlog = ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.Delete")
	defer func() { exit(err) }()

	_ = desired.(*resource)

	// Delete replication configuration by putting an empty configuration
	input := &svcsdk.PutReplicationConfigurationInput{
		ReplicationConfiguration: &types.ReplicationConfiguration{
			Rules: []types.ReplicationRule{},
		},
	}

	_, err = rm.sdkapi.PutReplicationConfiguration(ctx, input)
	rm.metrics.RecordAPICall("DELETE", "PutReplicationConfiguration", err)
	if err != nil {
		return nil, err
	}
	return desired, nil
}

// ClearResolvedReferences clears resolved references
func (rm *resourceManager) ClearResolvedReferences(
	r acktypes.AWSResource,
) acktypes.AWSResource {
	return r
}

// ARNFromName returns an AWS resource ARN from the supplied name
func (rm *resourceManager) ARNFromName(name string) string {
	return ""
}

// LateInitialize sets the late-initialized values from the AWS resource
func (rm *resourceManager) LateInitialize(
	ctx context.Context,
	latest acktypes.AWSResource,
) (acktypes.AWSResource, error) {
	return latest, nil
}

// EnsureTags ensures that tags are present inside the AWSResource.
func (rm *resourceManager) EnsureTags(
	ctx context.Context,
	r acktypes.AWSResource,
	md acktypes.ServiceControllerMetadata,
) error {
	// ReplicationConfiguration doesn't support tags
	return nil
}

// FilterSystemTags filters out system tags from the resource
func (rm *resourceManager) FilterSystemTags(
	r acktypes.AWSResource,
) {
	// ReplicationConfiguration doesn't support tags - no-op
}

// IsSynced returns true if the resource is synced
func (rm *resourceManager) IsSynced(ctx context.Context, r acktypes.AWSResource) (bool, error) {
	return true, nil // Simplified implementation
}

// ResolveReferences resolves references in the resource
func (rm *resourceManager) ResolveReferences(
	ctx context.Context,
	reader rtclient.Reader,
	r acktypes.AWSResource,
) (acktypes.AWSResource, bool, error) {
	return r, false, nil // No references to resolve for ReplicationConfiguration
}

// newResourceManager returns a new struct implementing
// acktypes.AWSResourceManager that handles CRUD operations on the supplied
// resource.
func newResourceManager(
	cfg ackcfg.Config,
	clientcfg aws.Config,
	log logr.Logger,
	metrics *ackmetrics.Metrics,
	rr acktypes.Reconciler,
	awsAccountID ackv1alpha1.AWSAccountID,
	awsRegion ackv1alpha1.AWSRegion,
) (*resourceManager, error) {
	return &resourceManager{
		rr:           rr.(acktypes.AWSResourceReconciler),
		awsAccountID: awsAccountID,
		awsRegion:    awsRegion,
		cfg:          cfg,
		log:          log,
		metrics:      metrics,
		sdkapi:       svcsdk.NewFromConfig(clientcfg),
	}, nil
}
