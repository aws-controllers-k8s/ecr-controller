// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

// Code generated by ack-generate. DO NOT EDIT.

package repository_creation_template

import (
	"context"

	ackv1alpha1 "github.com/aws-controllers-k8s/runtime/apis/core/v1alpha1"
	ackcompare "github.com/aws-controllers-k8s/runtime/pkg/compare"
	ackcfg "github.com/aws-controllers-k8s/runtime/pkg/config"
	ackmetrics "github.com/aws-controllers-k8s/runtime/pkg/metrics"
	ackrt "github.com/aws-controllers-k8s/runtime/pkg/runtime"
	ackrtlog "github.com/aws-controllers-k8s/runtime/pkg/runtime/log"
	acktypes "github.com/aws-controllers-k8s/runtime/pkg/types"
	ackutil "github.com/aws-controllers-k8s/runtime/pkg/util"
	"github.com/aws/aws-sdk-go-v2/aws"
	svcsdk "github.com/aws/aws-sdk-go-v2/service/ecr"
	"github.com/aws/aws-sdk-go-v2/service/ecr/types"
	"github.com/go-logr/logr"
	rtclient "sigs.k8s.io/controller-runtime/pkg/client"

	svcapitypes "github.com/aws-controllers-k8s/ecr-controller/apis/v1alpha1"
)

var (
	_ = ackutil.InStrings
	_ = ackrt.MissingImageTagValue
	_ = svcapitypes.RepositoryCreationTemplate{}
)

// +kubebuilder:rbac:groups=ecr.services.k8s.aws,resources=repositorycreationtemplates,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=ecr.services.k8s.aws,resources=repositorycreationtemplates/status,verbs=get;update;patch

// resourceManager is responsible for providing a consistent API to work with
// ECR API resources for repository creation templates.
type resourceManager struct {
	rr           acktypes.AWSResourceReconciler
	awsAccountID ackv1alpha1.AWSAccountID
	awsRegion    ackv1alpha1.AWSRegion
	cfg          ackcfg.Config
	log          logr.Logger
	metrics      *ackmetrics.Metrics
	sdkapi       *svcsdk.Client
}

// ReadOne returns resource state for a specific PK.
func (rm *resourceManager) ReadOne(
	ctx context.Context,
	r acktypes.AWSResource,
) (acktypes.AWSResource, error) {
	var err error
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.ReadOne")
	defer func() { exit(err) }()

	res := r.(*resource)

	input := &svcsdk.DescribeRepositoryCreationTemplateInput{
		Prefix: res.ko.Spec.RepositoryNamePrefix,
	}

	resp, err := rm.sdkapi.DescribeRepositoryCreationTemplate(ctx, input)
	rm.metrics.RecordAPICall("READ_ONE", "DescribeRepositoryCreationTemplate", err)
	if err != nil {
		rlog.Info("ReadOne: DescribeRepositoryCreationTemplate failed", "error", err)
		return nil, err
	}

	rlog.Info("ReadOne: DescribeRepositoryCreationTemplate succeeded")

	// Create a new resource with the response data
	ko := res.ko.DeepCopy()
	if resp.RepositoryCreationTemplate != nil {
		rlog.Info("ReadOne: Found AWS repository creation template", "prefix", res.ko.Spec.RepositoryNamePrefix)

		// Convert AWS SDK type to our API type
		ko.Spec.ImageTagMutability = (*string)(resp.RepositoryCreationTemplate.ImageTagMutability)

		if resp.RepositoryCreationTemplate.EncryptionConfiguration != nil {
			ko.Spec.EncryptionConfiguration = &svcapitypes.RepositoryEncryptionConfiguration{
				EncryptionType: (*string)(resp.RepositoryCreationTemplate.EncryptionConfiguration.EncryptionType),
				KmsKey:         resp.RepositoryCreationTemplate.EncryptionConfiguration.KmsKey,
			}
		}

		if resp.RepositoryCreationTemplate.ImageScanningConfiguration != nil {
			ko.Spec.ImageScanningConfiguration = &svcapitypes.ImageScanningConfiguration{
				ScanOnPush: resp.RepositoryCreationTemplate.ImageScanningConfiguration.ScanOnPush,
			}
		}

		ko.Spec.Description = resp.RepositoryCreationTemplate.Description

		if resp.RepositoryCreationTemplate.ResourceTags != nil {
			tags := make([]*svcapitypes.Tag, len(resp.RepositoryCreationTemplate.ResourceTags))
			for i, tag := range resp.RepositoryCreationTemplate.ResourceTags {
				tags[i] = &svcapitypes.Tag{
					Key:   tag.Key,
					Value: tag.Value,
				}
			}
			ko.Spec.ResourceTags = tags
		}

		// Set status fields
		ko.Status.RepositoryCreationTemplateARN = resp.RepositoryCreationTemplate.RepositoryCreationTemplateArn
		if resp.RepositoryCreationTemplate.CreatedAt != nil {
			t := metav1.NewTime(*resp.RepositoryCreationTemplate.CreatedAt)
			ko.Status.CreatedAt = &t
		}
		if resp.RepositoryCreationTemplate.UpdatedAt != nil {
			t := metav1.NewTime(*resp.RepositoryCreationTemplate.UpdatedAt)
			ko.Status.UpdatedAt = &t
		}
	}

	return newResource(rm.rr, ko), nil
}

// Create creates a repository creation template
func (rm *resourceManager) Create(
	ctx context.Context,
	desired acktypes.AWSResource,
) (created acktypes.AWSResource, cErr error) {
	var err error
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.Create")
	defer func() { exit(err) }()

	res := desired.(*resource)

	input := &svcsdk.CreateRepositoryCreationTemplateInput{
		Prefix: res.ko.Spec.RepositoryNamePrefix,
	}

	rlog.Info("Create: Processing repository creation template", "prefix", res.ko.Spec.RepositoryNamePrefix)

	// Add optional fields
	if res.ko.Spec.ImageTagMutability != nil {
		input.ImageTagMutability = types.ImageTagMutability(*res.ko.Spec.ImageTagMutability)
	}

	if res.ko.Spec.EncryptionConfiguration != nil {
		input.EncryptionConfiguration = &types.EncryptionConfiguration{
			EncryptionType: types.EncryptionType(*res.ko.Spec.EncryptionConfiguration.EncryptionType),
			KmsKey:         res.ko.Spec.EncryptionConfiguration.KmsKey,
		}
	}

	if res.ko.Spec.ImageScanningConfiguration != nil {
		input.ImageScanningConfiguration = &types.ImageScanningConfiguration{
			ScanOnPush: res.ko.Spec.ImageScanningConfiguration.ScanOnPush,
		}
	}

	if res.ko.Spec.Description != nil {
		input.Description = res.ko.Spec.Description
	}

	if res.ko.Spec.ResourceTags != nil {
		tags := make([]types.Tag, len(res.ko.Spec.ResourceTags))
		for i, tag := range res.ko.Spec.ResourceTags {
			tags[i] = types.Tag{
				Key:   tag.Key,
				Value: tag.Value,
			}
		}
		input.ResourceTags = tags
	}

	_, err = rm.sdkapi.CreateRepositoryCreationTemplate(ctx, input)
	rm.metrics.RecordAPICall("CREATE", "CreateRepositoryCreationTemplate", err)
	if err != nil {
		rlog.Info("Create: CreateRepositoryCreationTemplate failed", "error", err)
		return nil, err
	}

	rlog.Info("Create: CreateRepositoryCreationTemplate succeeded")

	// Read back the created resource
	return rm.ReadOne(ctx, desired)
}

// Update modifies a repository creation template
func (rm *resourceManager) Update(
	ctx context.Context,
	desired acktypes.AWSResource,
	latest acktypes.AWSResource,
	delta *ackcompare.Delta,
) (updated acktypes.AWSResource, uErr error) {
	var err error
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.Update")
	defer func() { exit(err) }()

	res := desired.(*resource)

	input := &svcsdk.UpdateRepositoryCreationTemplateInput{
		Prefix: res.ko.Spec.RepositoryNamePrefix,
	}

	rlog.Info("Update: Processing repository creation template", "prefix", res.ko.Spec.RepositoryNamePrefix)

	// Add optional fields that can be updated
	if res.ko.Spec.ImageTagMutability != nil {
		input.ImageTagMutability = types.ImageTagMutability(*res.ko.Spec.ImageTagMutability)
	}

	if res.ko.Spec.EncryptionConfiguration != nil {
		input.EncryptionConfiguration = &types.EncryptionConfiguration{
			EncryptionType: types.EncryptionType(*res.ko.Spec.EncryptionConfiguration.EncryptionType),
			KmsKey:         res.ko.Spec.EncryptionConfiguration.KmsKey,
		}
	}

	if res.ko.Spec.ImageScanningConfiguration != nil {
		input.ImageScanningConfiguration = &types.ImageScanningConfiguration{
			ScanOnPush: res.ko.Spec.ImageScanningConfiguration.ScanOnPush,
		}
	}

	if res.ko.Spec.Description != nil {
		input.Description = res.ko.Spec.Description
	}

	if res.ko.Spec.ResourceTags != nil {
		tags := make([]types.Tag, len(res.ko.Spec.ResourceTags))
		for i, tag := range res.ko.Spec.ResourceTags {
			tags[i] = types.Tag{
				Key:   tag.Key,
				Value: tag.Value,
			}
		}
		input.ResourceTags = tags
	}

	_, err = rm.sdkapi.UpdateRepositoryCreationTemplate(ctx, input)
	rm.metrics.RecordAPICall("UPDATE", "UpdateRepositoryCreationTemplate", err)
	if err != nil {
		rlog.Info("Update: UpdateRepositoryCreationTemplate failed", "error", err)
		return nil, err
	}

	rlog.Info("Update: UpdateRepositoryCreationTemplate succeeded")

	// Read back the updated resource
	return rm.ReadOne(ctx, desired)
}

// Delete removes a repository creation template
func (rm *resourceManager) Delete(
	ctx context.Context,
	desired acktypes.AWSResource,
) (acktypes.AWSResource, error) {
	var err error
	var rlog = ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.Delete")
	defer func() { exit(err) }()

	res := desired.(*resource)

	input := &svcsdk.DeleteRepositoryCreationTemplateInput{
		Prefix: res.ko.Spec.RepositoryNamePrefix,
	}

	_, err = rm.sdkapi.DeleteRepositoryCreationTemplate(ctx, input)
	rm.metrics.RecordAPICall("DELETE", "DeleteRepositoryCreationTemplate", err)
	if err != nil {
		rlog.Info("Delete: DeleteRepositoryCreationTemplate failed", "error", err)
		return nil, err
	}

	rlog.Info("Delete: DeleteRepositoryCreationTemplate succeeded")
	return desired, nil
}

// ClearResolvedReferences clears resolved references
func (rm *resourceManager) ClearResolvedReferences(
	r acktypes.AWSResource,
) acktypes.AWSResource {
	return r
}

// ARNFromName returns an AWS resource ARN from the supplied name
func (rm *resourceManager) ARNFromName(name string) string {
	return ""
}

// LateInitialize sets the late-initialized values from the AWS resource
func (rm *resourceManager) LateInitialize(
	ctx context.Context,
	latest acktypes.AWSResource,
) (acktypes.AWSResource, error) {
	return latest, nil
}

// EnsureTags ensures that tags are present inside the AWSResource.
func (rm *resourceManager) EnsureTags(
	ctx context.Context,
	r acktypes.AWSResource,
	md acktypes.ServiceControllerMetadata,
) error {
	// Tags are handled via ResourceTags field
	return nil
}

// FilterSystemTags filters out system tags from the resource
func (rm *resourceManager) FilterSystemTags(
	r acktypes.AWSResource,
) {
	// No system tag filtering needed
}

// IsSynced returns true if the resource is synced
func (rm *resourceManager) IsSynced(ctx context.Context, r acktypes.AWSResource) (bool, error) {
	var err error
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.IsSynced")
	defer func() { exit(err) }()

	res := r.(*resource)

	// Read current AWS state to compare with desired
	latest, err := rm.ReadOne(ctx, r)
	if err != nil {
		rlog.Info("IsSynced: Failed to read AWS state", "error", err)
		return false, err
	}

	latestRes := latest.(*resource)

	// Compare desired vs actual using delta
	delta := newResourceDelta(res, latestRes)
	if len(delta.Differences) == 0 {
		rlog.Info("IsSynced: Resource is synced - no differences found")
		return true, nil
	}

	rlog.Info("IsSynced: Resource not synced", "differences", len(delta.Differences))
	return false, nil
}

// ResolveReferences resolves references in the resource
func (rm *resourceManager) ResolveReferences(
	ctx context.Context,
	reader rtclient.Reader,
	r acktypes.AWSResource,
) (acktypes.AWSResource, bool, error) {
	return r, false, nil // No references to resolve
}

// newResourceManager returns a new struct implementing
// acktypes.AWSResourceManager that handles CRUD operations on the supplied
// resource.
func newResourceManager(
	cfg ackcfg.Config,
	clientcfg aws.Config,
	log logr.Logger,
	metrics *ackmetrics.Metrics,
	rr acktypes.Reconciler,
	awsAccountID ackv1alpha1.AWSAccountID,
	awsRegion ackv1alpha1.AWSRegion,
) (*resourceManager, error) {
	return &resourceManager{
		rr:           rr.(acktypes.AWSResourceReconciler),
		awsAccountID: awsAccountID,
		awsRegion:    awsRegion,
		cfg:          cfg,
		log:          log,
		metrics:      metrics,
		sdkapi:       svcsdk.NewFromConfig(clientcfg),
	}, nil
}
